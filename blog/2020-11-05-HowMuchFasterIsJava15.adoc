= How much faster is Java 15?
:page-interpolate: true
:awestruct-author: mtomco
:awestruct-layout: blogPostBase
:awestruct-tags: [production, benchmark]

Java 15 was released on the 15th of September 2020 and has promised to bring with it a few performance tweaks in its G1GC
and ParallelGC garbage collectors. What does it mean for
https://www.optaplanner.org/[OptaPlanner]? Have the improvements made in the G1GC outperformed the reigning champion since Java 8 or does the ParallelGC still
reign supreme on most use-cases? Is ParallelGC even faster than it was the previous time? Let's put it to the test!

This article is a follow up on our
https://www.optaplanner.org/blog/2019/01/17/HowMuchFasterIsJava11.html[ Java 11]
and our
https://www.optaplanner.org/blog/2014/03/20/HowMuchFasterIsJava8.html[Java 8] performance comparison benchmarks.

== Benchmark methodology

To run the benchmark we used:

* A stable machine without any other computational demanding processes running and with
`Intel® Xeon® Silver 4116 @ 2.1 GHz (12 cores total / 24 threads)` and `128 GiB` RAM memory, running `RHEL 8 x86_64`.

* Both G1 and Parallel GC for both Java versions to compare the impact of garbage collection.
Java executed with the parameters `-Xmx1536M -server -XX:+UseG1GC` and `-Xmx1536M -server -XX:+UseParallelGC` respectively.

* Both OpenJDK 11 version "11.0.6"
OpenJDK Runtime Environment 18.9 (build 11.0.6+10-LTS)
OpenJDK 64-Bit Server VM 18.9 (build 11.0.6+10-LTS, mixed mode)

* Both OpenJDK 15 version "15.0.1"
OpenJDK Runtime Environment 18.9 (build 15.0.1+9-LTS)
OpenJDK 64-Bit Server VM 18.9 (build 15.0.1+9-LTS, mixed mode)

* OptaPlanner `7.44.0.Final`

* Solving a planning problem involves *no IO* (except a few milliseconds during startup to load the input). *A single
CPU is completely saturated.* It constantly creates many short-lived objects, and the GC collects them afterwards.

* Each run solves 11 planning problems with OptaPlanner. Each planning problem runs for 5 minutes and starts with a
30 second JVM warm up which is discarded.

* The benchmarks measure the number of scores calculated per millisecond. Higher is better. Calculating
a score for a proposed planning solution is non-trivial: it involves many calculations, including checking for
conflicts between every entity and every other entity.

== Executive summary

With Java 15, the average improvement is *10.5%* for G1 and *6.2%* for Parallel GC. The difference between the two
garbage collectors running on JDK 15 is *10.7%* leaning in favor of Parallel GC.
For more information about difference between various GC algorithms, please see
https://dzone.com/articles/choosing-the-best-garbage-collection-algorithm-for[this article].

The Parallel GC is the superior GC for OptaPlanner than G1, since the throughput is still the most relevant factor when it comes to garbage collection.

== Results

=== Java 11 vs. Java 15

image::JDK11andJDK15UsingG1GC.svg[]

[#table1]
.Score calculation count per second with G1 GC
|===
| 2+^.^|Cloud balancing 2+^.^|Machine reassignment 2+^.^|Course scheduling 2+^.^|Exam scheduling 2+^.^|Nurse rostering^.^|Traveling Tournament
|JDK ^|200c ^|800c ^|B1 ^|B10 ^|c7 ^|c8 ^|s2 ^|s3 ^|m1 ^|mh1 ^|nl14
|OpenJDK 11 >|77,073 >|75,343 >|239,262 >|37,991 >|6,861 >|8,577 >|12,748 >|8,375 >|3,047 >|2,872 >|1,905
|JDK 15 >|79,275 >|76,276 >|298,923 >|39,883 >|7,694 >|10,049 >|14,438 >|9,421 >|3,384 >|3,155 >|2,015
|Difference >|2.9% >|1.2% >|25.0% >|5.0% >|12.1% >|17.2% >|13.3% >|12.5% >|11.0% >|9.9% >|5.8%
|Average 11+^.^|*10.5%*
|===

image::JDK11andJDK15UsingParallelGC.svg[]


.Score calculation count per second with Parallel GC
|===
| 2+^.^|Cloud balancing 2+^.^|Machine reassignment 2+^.^|Course scheduling 2+^.^|Exam scheduling 2+^.^|Nurse rostering^.^|Traveling Tournament
|JDK ^|200c ^|800c ^|B1 ^|B10 ^|c7 ^|c8 ^|s2 ^|s3 ^|m1 ^|mh1 ^|nl14
|OpenJDK 11 >|95,716 >|91,519 >|313,653 >|29,254 >|8,079 >|10,510 >|14,842 >|9,474 >|3,810 >|3,518 >|2,641
|JDK 15	>|100,246 >|95,220 >|309,048 >|26,090 >|9,109 >|11,690 >|16,529 >|10,827 >|4,209 >|3,921 >|2,657
|Difference >|4.7% >|4.0% >|-1.5% >|-10.9% >|12.8% >|11.2% >|11.4% >|14.3% >|10.5% >|11.5% >|0.6%
|Average 11+^.^|*6.2%*
|===


=== Parallel GC vs. G1 GC on Java 15

image::G1GCandParallelGCUsingJDK15.svg.svg[]


[#table3]
.Comparison of score calculation count per second on Java 15 with Parallel GC and G1 GC being used
|===
| 2+^.^|Cloud balancing 2+^.^|Machine reassignment 2+^.^|Course scheduling 2+^.^|Exam scheduling 2+^.^|Nurse rostering^.^|Traveling Tournament
|Java 15 ^|200c ^|800c ^|B1 ^|B10 ^|c7 ^|c8 ^|s2 ^|s3 ^|m1 ^|mh1 ^|nl14
|JDK 15 G1GC >|79,275 >|76,276 >|298,923 >|39,883 >|7,694 >|10,049 >|14,438 >|9,421 >|3,384 >|3,155 >|2,015
|JDK 15	ParallelGC >|100,246 >|95,220 >|309,048 >|26,090 >|9,109 >|11,690 >|16,529 >|10,827 >|4,209 >|3,921 >|2,657
|Difference >|20.92% >|24.8% >|3.4% >|-34.6% >|18.4% >|16.3% >|14.5% >|14.9% >|24.4% >|24.3% >|31.9%
|Average 11+^.^|*10.7%*
|===

== Conclusion

For running OptaPlanner, the best garbage collector to use is still ParallelGC, which performance is even better in comparison with G1GC than it was in JDK11.